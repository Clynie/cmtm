function o = interp(tr,or,t);% o = interp(tr,or,t);% does interpolation and extrapolation to target (tr,or)%%This is the same as Rich Muller's interp.m, but now Matlab %has come out with a function of their own called interp.% find range k1,k2 for which ordinary interp1 works ok	nr = length(tr);	n  = length(t);	tmin = tr(1);	tmax = tr(nr);	for k = 1:n;		if t(n-k+1) >= tmin; k1 = n-k+1; end;		if t(k)     <= tmax; k2 = k;     end;		end;o = zeros(n,1);o(k1:k2) = interp1(tr,or,t(k1:k2));% extrapolate outside the range k1:k2if k1>1	m = (or(2)-or(1))/(tr(2)-tr(1));	% beginning slope	o(1:k1-1) = or(1) - m*(tr(1)-t(1:k1-1));	end;if k2<n;	m = (or(nr)-or(nr-1))/(tr(nr)-tr(nr-1));	% end slope	o(k2+1:n) = or(nr) + m*(t(k2+1:n)-tr(nr));	% this line is wrong	end;	